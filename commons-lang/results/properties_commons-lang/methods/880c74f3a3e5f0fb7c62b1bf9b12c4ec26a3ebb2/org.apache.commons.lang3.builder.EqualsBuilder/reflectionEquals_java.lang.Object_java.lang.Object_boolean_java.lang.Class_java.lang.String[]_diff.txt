/**                                                                                                    /**                                                                                                 
* &lt;p&gt;This method uses reflection to determine if the two &lt;code&gt;Object&lt;/code&gt;s        * &lt;p&gt;This method uses reflection to determine if the two &lt;code&gt;Object&lt;/code&gt;s     
* are equal.&lt;/p&gt;                                                                                 * are equal.&lt;/p&gt;                                                                              
*                                                                                                      *                                                                                                   
* &lt;p&gt;It uses &lt;code&gt;AccessibleObject.setAccessible&lt;/code&gt; to gain access to private   * &lt;p&gt;It uses &lt;code&gt;AccessibleObject.setAccessible&lt;/code&gt; to gain access to private
* fields. This means that it will throw a security exception if run under                              * fields. This means that it will throw a security exception if run under                           
* a security manager, if the permissions are not set up correctly. It is also                          * a security manager, if the permissions are not set up correctly. It is also                       
* not as efficient as testing explicitly.&lt;/p&gt;                                                    * not as efficient as testing explicitly.&lt;/p&gt;                                                 
*                                                                                                      *                                                                                                   
* &lt;p&gt;If the testTransients parameter is set to &lt;code&gt;true&lt;/code&gt;, transient          * &lt;p&gt;If the testTransients parameter is set to &lt;code&gt;true&lt;/code&gt;, transient       
* members will be tested, otherwise they are ignored, as they are likely                               * members will be tested, otherwise they are ignored, as they are likely                            
* derived fields, and not part of the value of the &lt;code&gt;Object&lt;/code&gt;.&lt;/p&gt;          * derived fields, and not part of the value of the &lt;code&gt;Object&lt;/code&gt;.&lt;/p&gt;       
*                                                                                                      *                                                                                                   
* &lt;p&gt;Static fields will not be included. Superclass fields will be appended                      * &lt;p&gt;Static fields will not be included. Superclass fields will be appended                   
* up to and including the specified superclass. A null superclass is treated                           * up to and including the specified superclass. A null superclass is treated                        
* as java.lang.Object.&lt;/p&gt;                                                                       * as java.lang.Object.&lt;/p&gt;                                                                    
*                                                                                                      *                                                                                                   
* @param lhs  &lt;code&gt;this&lt;/code&gt; object                                                     * @param lhs  &lt;code&gt;this&lt;/code&gt; object                                                  
* @param rhs  the other object                                                                         * @param rhs  the other object                                                                      
* @param testTransients  whether to include transient fields                                           * @param testTransients  whether to include transient fields                                        
* @param reflectUpToClass  the superclass to reflect up to (inclusive),                                * @param reflectUpToClass  the superclass to reflect up to (inclusive),                             
*  may be &lt;code&gt;null&lt;/code&gt;                                                                *  may be &lt;code&gt;null&lt;/code&gt;                                                             
* @param excludeFields  array of field names to exclude from testing                                   * @param excludeFields  array of field names to exclude from testing                                
* @return &lt;code&gt;true&lt;/code&gt; if the two Objects have tested equals.                         * @return &lt;code&gt;true&lt;/code&gt; if the two Objects have tested equals.                      
* @since 2.0                                                                                           * @since 2.0                                                                                        
*/                                                                                                     */                                                                                                  
public static boolean reflectionEquals(Object lhs, Object rhs, boolean testTransients, Class&lt;?&gt | public static boolean reflectionEquals(Object lhs, Object rhs, boolean testTransients, Class&lt;?&gt
if (lhs == rhs) {                                                                                      if (lhs == rhs) {                                                                                   
return true;                                                                                           return true;                                                                                        
}                                                                                                      }                                                                                                   
if (lhs == null || rhs == null) {                                                                      if (lhs == null || rhs == null) {                                                                   
return false;                                                                                          return false;                                                                                       
}                                                                                                      }                                                                                                   
// Find the leaf class since there may be transients in the leaf                                       // Find the leaf class since there may be transients in the leaf                                    
// class or in classes between the leaf and root.                                                      // class or in classes between the leaf and root.                                                   
// If we are not testing transients or a subclass has no ivars,                                        // If we are not testing transients or a subclass has no ivars,                                     
// then a subclass can test equals to a superclass.                                                    // then a subclass can test equals to a superclass.                                                 
Class&lt;?&gt; lhsClass = lhs.getClass();                                                              Class&lt;?&gt; lhsClass = lhs.getClass();                                                           
Class&lt;?&gt; rhsClass = rhs.getClass();                                                              Class&lt;?&gt; rhsClass = rhs.getClass();                                                           
Class&lt;?&gt; testClass;                                                                              Class&lt;?&gt; testClass;                                                                           
if (lhsClass.isInstance(rhs)) {                                                                        if (lhsClass.isInstance(rhs)) {                                                                     
testClass = lhsClass;                                                                                  testClass = lhsClass;                                                                               
if (!rhsClass.isInstance(lhs)) {                                                                       if (!rhsClass.isInstance(lhs)) {                                                                    
// rhsClass is a subclass of lhsClass                                                                  // rhsClass is a subclass of lhsClass                                                               
testClass = rhsClass;                                                                                  testClass = rhsClass;                                                                               
}                                                                                                      }                                                                                                   
} else if (rhsClass.isInstance(lhs)) {                                                                 } else if (rhsClass.isInstance(lhs)) {                                                              
testClass = rhsClass;                                                                                  testClass = rhsClass;                                                                               
if (!lhsClass.isInstance(rhs)) {                                                                       if (!lhsClass.isInstance(rhs)) {                                                                    
// lhsClass is a subclass of rhsClass                                                                  // lhsClass is a subclass of rhsClass                                                               
testClass = lhsClass;                                                                                  testClass = lhsClass;                                                                               
}                                                                                                      }                                                                                                   
} else {                                                                                               } else {                                                                                            
// The two classes are not related.                                                                    // The two classes are not related.                                                                 
return false;                                                                                          return false;                                                                                       
}                                                                                                      }                                                                                                   
EqualsBuilder equalsBuilder = new EqualsBuilder();                                                     EqualsBuilder equalsBuilder = new EqualsBuilder();                                                  
try {                                                                                                  try {                                                                                               
reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);                   reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);                
while (testClass.getSuperclass() != null && testClass != reflectUpToClass) {                           while (testClass.getSuperclass() != null && testClass != reflectUpToClass) {                        
testClass = testClass.getSuperclass();                                                                 testClass = testClass.getSuperclass();                                                              
reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);                   reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);                
}                                                                                                      }                                                                                                   
} catch (IllegalArgumentException e) {                                                                 } catch (IllegalArgumentException e) {                                                              
// In this case, we tried to test a subclass vs. a superclass and                                      // In this case, we tried to test a subclass vs. a superclass and                                   
// the subclass has ivars or the ivars are transient and                                               // the subclass has ivars or the ivars are transient and                                            
// we are testing transients.                                                                          // we are testing transients.                                                                       
// If a subclass has ivars that we are trying to test them, we get an                                  // If a subclass has ivars that we are trying to test them, we get an                               
// exception and we know that the objects are not equal.                                               // exception and we know that the objects are not equal.                                            
return false;                                                                                          return false;                                                                                       
}                                                                                                      }                                                                                                   
return equalsBuilder.isEquals();                                                                       return equalsBuilder.isEquals();                                                                    
}                                                                                                      }                                                                                                   
