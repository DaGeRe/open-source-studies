/**                                                                                                    /**                                                                                                 
* Implement add and subtract using algorithm described in Knuth 4.5.1.                                 * Implement add and subtract using algorithm described in Knuth 4.5.1.                              
*                                                                                                      *                                                                                                   
* @param fraction the fraction to subtract, must not be &lt;code&gt;null&lt;/code&gt;                  * @param fraction the fraction to subtract, must not be &lt;code&gt;null&lt;/code&gt;               
* @param isAdd true to add, false to subtract                                                          * @param isAdd true to add, false to subtract                                                       
* @return a &lt;code&gt;Fraction&lt;/code&gt; instance with the resulting values                       * @return a &lt;code&gt;Fraction&lt;/code&gt; instance with the resulting values                    
* @throws IllegalArgumentException if the fraction is &lt;code&gt;null&lt;/code&gt;                    * @throws IllegalArgumentException if the fraction is &lt;code&gt;null&lt;/code&gt;                 
* @throws ArithmeticException if the resulting numerator or denominator                                * @throws ArithmeticException if the resulting numerator or denominator                             
*   cannot be represented in an &lt;code&gt;int&lt;/code&gt;.                                          *   cannot be represented in an &lt;code&gt;int&lt;/code&gt;.                                       
*/                                                                                                     */                                                                                                  
private Fraction addSub(Fraction fraction, boolean isAdd) {                                            private Fraction addSub(Fraction fraction, boolean isAdd) {                                         
if (fraction == null) {                                                                                if (fraction == null) {                                                                             
throw new IllegalArgumentException("The fraction must not be null");                                   throw new IllegalArgumentException("The fraction must not be null");                                
}                                                                                                      }                                                                                                   
// zero is identity for addition.                                                                      // zero is identity for addition.                                                                   
if (numerator == 0) {                                                                                  if (numerator == 0) {                                                                               
return isAdd ? fraction : fraction.negate();                                                           return isAdd ? fraction : fraction.negate();                                                        
}                                                                                                      }                                                                                                   
if (fraction.numerator == 0) {                                                                         if (fraction.numerator == 0) {                                                                      
return this;                                                                                           return this;                                                                                        
}                                                                                                      }                                                                                                   
// if denominators are randomly distributed, d1 will be 1 about 61%                                    // if denominators are randomly distributed, d1 will be 1 about 61%                                 
// of the time.                                                                                        // of the time.                                                                                     
int d1 = greatestCommonDivisor(denominator, fraction.denominator);                                     int d1 = greatestCommonDivisor(denominator, fraction.denominator);                                  
if (d1 == 1) {                                                                                         if (d1 == 1) {                                                                                      
// result is ( (u*v' +/- u'v) / u'v')                                                                  // result is ( (u*v' +/- u'v) / u'v')                                                               
int uvp = mulAndCheck(numerator, fraction.denominator);                                                int uvp = mulAndCheck(numerator, fraction.denominator);                                             
int upv = mulAndCheck(fraction.numerator, denominator);                                                int upv = mulAndCheck(fraction.numerator, denominator);                                             
return new Fraction(isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv), mulPosAndCheck(denominato   return new Fraction(isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv), mulPosAndCheck(denominato
}                                                                                                      }                                                                                                   
// the quantity 't' requires 65 bits of precision; see knuth 4.5.1                                     // the quantity 't' requires 65 bits of precision; see knuth 4.5.1                                  
// exercise 7.  we're going to use a BigInteger.                                                       // exercise 7.  we're going to use a BigInteger.                                                    
// t = u(v'/d1) +/- v(u'/d1)                                                                           // t = u(v'/d1) +/- v(u'/d1)                                                                        
BigInteger uvp = BigInteger.valueOf(numerator).multiply(BigInteger.valueOf(fraction.denominator / d1   BigInteger uvp = BigInteger.valueOf(numerator).multiply(BigInteger.valueOf(fraction.denominator / d1
BigInteger upv = BigInteger.valueOf(fraction.numerator).multiply(BigInteger.valueOf(denominator / d1   BigInteger upv = BigInteger.valueOf(fraction.numerator).multiply(BigInteger.valueOf(denominator / d1
BigInteger t = isAdd ? uvp.add(upv) : uvp.subtract(upv);                                               BigInteger t = isAdd ? uvp.add(upv) : uvp.subtract(upv);                                            
// but d2 doesn't need extra precision because                                                         // but d2 doesn't need extra precision because                                                      
// d2 = gcd(t,d1) = gcd(t mod d1, d1)                                                                  // d2 = gcd(t,d1) = gcd(t mod d1, d1)                                                               
int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();                                                 int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();                                              
int d2 = (tmodd1 == 0) ? d1 : greatestCommonDivisor(tmodd1, d1);                                     | int d2 = tmodd1 == 0 ? d1 : greatestCommonDivisor(tmodd1, d1);                                      
// result is (t/d2) / (u'/d1)(v'/d2)                                                                   // result is (t/d2) / (u'/d1)(v'/d2)                                                                
BigInteger w = t.divide(BigInteger.valueOf(d2));                                                       BigInteger w = t.divide(BigInteger.valueOf(d2));                                                    
if (w.bitLength() &gt; 31) {                                                                           if (w.bitLength() &gt; 31) {                                                                        
throw new ArithmeticException("overflow: numerator too large after multiply");                         throw new ArithmeticException("overflow: numerator too large after multiply");                      
}                                                                                                      }                                                                                                   
return new Fraction(w.intValue(), mulPosAndCheck(denominator / d1, fraction.denominator / d2));        return new Fraction(w.intValue(), mulPosAndCheck(denominator / d1, fraction.denominator / d2));     
}                                                                                                      }                                                                                                   
