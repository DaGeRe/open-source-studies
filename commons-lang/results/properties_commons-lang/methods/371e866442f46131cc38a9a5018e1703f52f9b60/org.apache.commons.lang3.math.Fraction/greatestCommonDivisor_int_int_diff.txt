/**                                                                                                    /**                                                                                                 
* &lt;p&gt;Gets the greatest common divisor of the absolute value of                                   * &lt;p&gt;Gets the greatest common divisor of the absolute value of                                
* two numbers, using the "binary gcd" method which avoids                                              * two numbers, using the "binary gcd" method which avoids                                           
* division and modulo operations.  See Knuth 4.5.2 algorithm B.                                        * division and modulo operations.  See Knuth 4.5.2 algorithm B.                                     
* This algorithm is due to Josef Stein (1961).&lt;/p&gt;                                               * This algorithm is due to Josef Stein (1961).&lt;/p&gt;                                            
*                                                                                                      *                                                                                                   
* @param u  a non-zero number                                                                          * @param u  a non-zero number                                                                       
* @param v  a non-zero number                                                                          * @param v  a non-zero number                                                                       
* @return the greatest common divisor, never zero                                                      * @return the greatest common divisor, never zero                                                   
*/                                                                                                     */                                                                                                  
private static int greatestCommonDivisor(int u, int v) {                                               private static int greatestCommonDivisor(int u, int v) {                                            
// From Commons Math:                                                                                  // From Commons Math:                                                                               
if ((u == 0) || (v == 0)) {                                                                          | if (u == 0 || v == 0) {                                                                             
if ((u == Integer.MIN_VALUE) || (v == Integer.MIN_VALUE)) {                                          | if (u == Integer.MIN_VALUE || v == Integer.MIN_VALUE) {                                             
throw new ArithmeticException("overflow: gcd is 2^31");                                                throw new ArithmeticException("overflow: gcd is 2^31");                                             
}                                                                                                      }                                                                                                   
return Math.abs(u) + Math.abs(v);                                                                      return Math.abs(u) + Math.abs(v);                                                                   
}                                                                                                      }                                                                                                   
// if either operand is abs 1, return 1:                                                               // if either operand is abs 1, return 1:                                                            
if (Math.abs(u) == 1 || Math.abs(v) == 1) {                                                            if (Math.abs(u) == 1 || Math.abs(v) == 1) {                                                         
return 1;                                                                                              return 1;                                                                                           
}                                                                                                      }                                                                                                   
// keep u and v negative, as negative integers range down to                                           // keep u and v negative, as negative integers range down to                                        
// -2^31, while positive numbers can only be as large as 2^31-1                                        // -2^31, while positive numbers can only be as large as 2^31-1                                     
// (i.e. we can't necessarily negate a negative number without                                         // (i.e. we can't necessarily negate a negative number without                                      
// overflow)                                                                                           // overflow)                                                                                        
// make u negative                                                                                     // make u negative                                                                                  
if (u &gt; 0) {                                                                                        if (u &gt; 0) {                                                                                     
u = -u;                                                                                                u = -u;                                                                                             
}                                                                                                      }                                                                                                   
// make v negative                                                                                     // make v negative                                                                                  
if (v &gt; 0) {                                                                                        if (v &gt; 0) {                                                                                     
v = -v;                                                                                                v = -v;                                                                                             
}                                                                                                      }                                                                                                   
// B1. [Find power of 2]                                                                               // B1. [Find power of 2]                                                                            
int k = 0;                                                                                             int k = 0;                                                                                          
while ((u & 1) == 0 && (v & 1) == 0 && k &lt; 31) {                                                    while ((u & 1) == 0 && (v & 1) == 0 && k &lt; 31) {                                                 
// while u and v are both even...                                                                      // while u and v are both even...                                                                   
// cast out twos.                                                                                      // cast out twos.                                                                                   
u /= 2;                                                                                                u /= 2;                                                                                             
// cast out twos.                                                                                      // cast out twos.                                                                                   
v /= 2;                                                                                                v /= 2;                                                                                             
// cast out twos.                                                                                      // cast out twos.                                                                                   
k++;                                                                                                   k++;                                                                                                
}                                                                                                      }                                                                                                   
if (k == 31) {                                                                                         if (k == 31) {                                                                                      
throw new ArithmeticException("overflow: gcd is 2^31");                                                throw new ArithmeticException("overflow: gcd is 2^31");                                             
}                                                                                                      }                                                                                                   
// B2. Initialize: u and v have been divided by 2^k and at least                                       // B2. Initialize: u and v have been divided by 2^k and at least                                    
// one is odd.                                                                                         // one is odd.                                                                                      
int t = ((u & 1) == 1) ? v : -(u / 2);                                                               | int t = (u & 1) == 1 ? v : -(u / 2);                                                                
// t negative: u was odd, v may be even (t replaces v)                                                 // t negative: u was odd, v may be even (t replaces v)                                              
// t positive: u was even, v is odd (t replaces u)                                                     // t positive: u was even, v is odd (t replaces u)                                                  
do {                                                                                                   do {                                                                                                
/* assert u&lt;0 && v&lt;0; */                                                                         /* assert u&lt;0 && v&lt;0; */                                                                      
// B4/B3: cast out twos from t.                                                                        // B4/B3: cast out twos from t.                                                                     
while ((t & 1) == 0) {                                                                                 while ((t & 1) == 0) {                                                                              
// while t is even..                                                                                   // while t is even..                                                                                
// cast out twos                                                                                       // cast out twos                                                                                    
t /= 2;                                                                                                t /= 2;                                                                                             
}                                                                                                      }                                                                                                   
// B5 [reset max(u,v)]                                                                                 // B5 [reset max(u,v)]                                                                              
if (t &gt; 0) {                                                                                        if (t &gt; 0) {                                                                                     
u = -t;                                                                                                u = -t;                                                                                             
} else {                                                                                               } else {                                                                                            
v = t;                                                                                                 v = t;                                                                                              
}                                                                                                      }                                                                                                   
// B6/B3. at this point both u and v should be odd.                                                    // B6/B3. at this point both u and v should be odd.                                                 
t = (v - u) / 2;                                                                                       t = (v - u) / 2;                                                                                    
// |u| larger: t positive (replace u)                                                                  // |u| larger: t positive (replace u)                                                               
// |v| larger: t negative (replace v)                                                                  // |v| larger: t negative (replace v)                                                               
} while (t != 0);                                                                                      } while (t != 0);                                                                                   
// gcd is u*2^k                                                                                        // gcd is u*2^k                                                                                     
return -u * (1 &lt;&lt; k);                                                                            return -u * (1 &lt;&lt; k);                                                                         
}                                                                                                      }                                                                                                   
